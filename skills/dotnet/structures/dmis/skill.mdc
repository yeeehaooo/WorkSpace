---
type: structure
name: dotnet/structures/dmis
description: DMIS Enterprise Backend Structure (Clean Architecture + DDD + CQRS + Vertical Slice)
---

# DMIS Enterprise Structure

## Philosophy

DMIS is an opinionated enterprise backend structure built on:

- Clean Architecture
- Domain-Driven Design (DDD)
- CQRS
- Vertical Slice API Design
- Dapper-first persistence strategy

This structure enforces strict layer boundaries and responsibility separation.

---

# Tech Stack

- .NET 10
- Dapper
- EF Core
- Redis
- JWT
- Serilog

---

# Architectural Layers

The system MUST follow a four-layer architecture:

1. Api
2. Application
3. Domain
4. Infrastructure

Dependency direction MUST follow:

Api → Application → Domain
Infrastructure → Application / Domain
Domain MUST NOT depend on any outer layer.

---

# Layer Responsibilities

## Api Layer

- Entry point (ASP.NET Core Web API)
- Vertical slice module organization
- Endpoint / Request / Response separation
- Mapping between API DTO and Application DTO
- Pipeline configuration
- Authentication filter
- Logging middleware
- Workflow initialization

Api MUST NOT contain business logic.

---

## Application Layer

- Use case coordination
- Command / Query handlers
- Result abstraction
- UnitOfWork abstraction
- Workflow abstraction
- Decorator-based cross-cutting concerns

Application MUST NOT depend on Infrastructure implementations.

---

## Domain Layer

- Aggregate Roots
- Value Objects
- Domain Guards
- Smart Enums
- Domain Exceptions
- Error Codes

Domain MUST contain pure business rules only.
No framework references allowed.

---

## Infrastructure Layer

- Dapper implementation (primary persistence)
- EF Core (optional secondary ORM)
- Repository implementation
- Query Services (Read side of CQRS)
- Redis cache implementation
- JWT authentication service
- Encryption services (RSA / AES-GCM)
- Logging implementation (Serilog)

Infrastructure MUST implement Application abstractions.

---

# Folder Organization Rules

## Api Layer

Must follow vertical slice:

```
Modules/{ModuleName}/{UseCase}/
- Endpoint
- Request
- Response
- Mapping
```

No shared Controller dumping allowed.

**Folder Conventions:**
- API/Modules/{Feature}/{Action}

---

## Application Layer

```
Modules/{ModuleName}/Commands/
Modules/{ModuleName}/Queries/
```

Each use case must have:

- Command or Query
- Handler
- Result

**Folder Conventions:**
- Application/Modules/{Feature}/Commands

---

## Domain Layer

```
Modules/{ModuleName}/
Kernel/
- AggregateRoot
- IRepository
- Guards
- SmartEnums
- ErrorCodes
```

Domain must not reference:
- ASP.NET
- EF Core
- Dapper
- Logging framework

---

## Infrastructure Layer

```
Persistence/
- Dappers/
- Repositories/
- QueryServices/
- ReadModels/
- DataModels/

Security/
- Authentication
- Cryptography
- Integrity

Caching/
Logging/
```

**Folder Conventions:**
- Infrastructure/Persistence/Dappers

---

# Persistence Strategy

Primary persistence: Dapper
Transaction handling via UnitOfWork abstraction.

CQRS separation:

- Write → Repository
- Read → QueryService + ReadModel

---

# Cross-Cutting Strategy

Cross-cutting concerns MUST use:

- Decorator pattern (Application layer)
- Middleware / Filters (Api layer)

No business logic allowed in middleware.

---

# What DMIS Assumes

This structure assumes usage of the following pattern skills:

- result pattern
- guard pattern
- unit-of-work pattern
- workflow pattern
- smart-enum pattern

These are NOT embedded here.
They must be explicitly selected in project-profile.json.

---

# Non-Goals

DMIS does NOT define:

- Concrete business entities
- Database schema
- DevOps pipeline
- CI/CD configuration

It only defines architectural structure.

---

# Enforcement Rules

The following are considered violations:

- Domain referencing Infrastructure
- Api referencing Infrastructure directly
- Business logic inside Controllers
- EF DbContext used directly inside Application
- Dapper used outside Infrastructure
